<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="http://www.j4nu5.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="http://www.j4nu5.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="http://www.j4nu5.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Kushagra Sinha">
  <meta name="description" content="Posts and writings by Kushagra Sinha">

  <link href="http://www.j4nu5.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="The Janus List Atom" />

<meta name="keywords" content="programming">

  <title>
    The Janus List
&ndash; Generating Power&nbsp;Set  </title>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24193913-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="http://www.j4nu5.com">
        <img src="/images/pic.jpeg" alt="logo">
      </a>
      <h2><a href="http://www.j4nu5.com">Kushagra Sinha</a></h2>
      <p></p>
      <ul>
        <li><a href="http://www.j4nu5.com/pages/about.html">About</a></li>
        <li><a href="http://www.j4nu5.com/pages/contact.html">Contact</a></li>
        <li><a href="https://twitter.com/j4nu5" target="_blank">Twitter</a></li>
        <li><a href="https://www.linkedin.com/in/sinhakushagra" target="_blank">LinkedIn</a></li>
        <li><a href="https://github.com/j4nu5/" target="_blank">GitHub</a></li>
        <li><a href="https://plus.google.com/+KushagraSinha/" target="_blank">Google+</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="http://www.j4nu5.com">Index</a> &brvbar; <a href="http://www.j4nu5.com/archives.html">Archives</a>
      &brvbar; <a href="http://www.j4nu5.com/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h3><a href="http://www.j4nu5.com/generating-power-set.html">Generating Power&nbsp;Set</a></h3>
  </div>
  <div class="article_text">
    <p>Iterating over all possible subsets of a set is a problem that can arise not
only in competitive programming but also in day-to-day programming. While the
total number of possible subsets is quite huge (<cite>2^n</cite> where <cite>n</cite> is the
cardinality of the input set), often we want an algorithm that systematically
considers all subsets for small values of <cite>n</cite>.</p>
<p>A <a class="reference external" href="http://en.wikipedia.org/wiki/Power_set">power set</a> is a set of all subsets
of a given input set. Often we may want to simply iterate over all members of
the power set, but sometimes (if we have enough memory) we may need the power
set itself. In the following post, I have attempted to present some algorithms
(with C++11 implementations) that solve both kinds of problems (simple
iteration and complete power set&nbsp;construction).</p>
<div class="section" id="recursive-algorithm-for-power-set-generation">
<h2>Recursive algorithm for power set&nbsp;generation</h2>
<p>Power set generation is a problem that yields naturally to a recursive
algorithm. Consider a set say, <span class="formula">{1,â€…2,â€…3,â€…4}</span>. If we had a
function that can generate the power set, <span class="formula">ğ•Š</span>, of
<span class="formula">{2,â€…3,â€…4}</span> we can generate the power set of the original
input set by appending 1 to each member of <span class="formula">ğ•Š</span> (call the result
<span class="formula">ğ•‹</span>) and then taking the union of <span class="formula">ğ•Š</span> and
<span class="formula">ğ•‹</span>.</p>
<p>As an example, let us try generating the powerset of <span class="formula">{1,â€…2,â€…3}</span>.
The power set of <span class="formula">{2,â€…3},â€…ğ•Š,â€…</span> is
<span class="formula">{<i>Ï†</i>,â€…{2},â€…{3},â€…{2,â€…3}}</span>.
Adding <span class="formula">1</span> to each member of <span class="formula">ğ•Š</span>, gives us, <span class="formula">ğ•‹</span>,
<span class="formula">{{1},â€…{1,â€…2},â€…{1,â€…3},â€…{1,â€…2,â€…3}}</span>.
Union of <span class="formula">ğ•Š</span> and <span class="formula">ğ•‹</span> gives us the required answer:
<span class="formula">{<i>Ï†</i>,â€…{2},â€…{3},â€…{2,â€…3},â€…{1},â€…{1,â€…2},â€…{1,â€…3},â€…{1,â€…2,â€…3}}</span>.</p>
<p>Translating the above idea to code&nbsp;(C++11):</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Accepts a set of integers and optionally a position to start reading the</span>
<span class="c1">// array from.</span>
<span class="c1">// Returns the powerset of integers from arr [pos=0 ... arr.size()-1]</span>
<span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">powerset1</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr_size</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">arr_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Recursion base case</span>
        <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">powerset1</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">rest</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">subset</span> <span class="p">:</span> <span class="n">rest</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">subset</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>
        <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">subset</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table><p>I have assumed a set of integers that do not have duplicates. The code can be
easily modified to accept other datatypes or maybe templates. If the vector has
duplicate elements, just copy and deduplicate it before&nbsp;passing.</p>
<p>Since this method returns the complete power set, the space complexity is of the
order of <cite>2 ^ n</cite>. The time complexity is&nbsp;exponential.</p>
</div>
<div class="section" id="iterative-algorithm-same-idea">
<h2>Iterative algorithm, same&nbsp;idea</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">powerset2</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr_size</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pset</span><span class="p">;</span>
    <span class="n">pset</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">pset</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">subset</span> <span class="p">:</span> <span class="n">tmp</span><span class="p">)</span>
            <span class="n">subset</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>
        <span class="n">copy</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tmp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">pset</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pset</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="iterating-over-power-set-using-a-bitmask-lexical-ordering">
<h2>Iterating over power set, using a bitmask (lexical&nbsp;ordering)</h2>
<p>We can use a bitmask of length = size of input set to denote a subset choice.
For example, a selection of {1, 2} in {1, 2, 3, 4} can be denoted by 0011,
where the <span class="caps">LSB</span> (least significant bit) denotes 0th index and <span class="caps">MSB</span> denotes the
higest possible index (<cite>arr.size() - 1</cite>). <span class="formula"><i>Ï†</i></span> is denoted by 0000 and a
selection of all integers is denoted by&nbsp;1111.</p>
<p>According to this idea, each set in the powerset can be represented by a bitmask.
Therefore, iterating over all possible bitmasks will do the trick. Note that
all possible bitmasks of length <cite>n</cite> is simply [0 &#8230; 2^n -&nbsp;1].</p>
<p>This solution is sufficient for most practical applications running on a single
computer. I am going to use a 64-bit unsigned long long for this. If you have a
set bigger than this, you cannot do it in a reasonable amount of time on a
single&nbsp;machine.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">powerset3</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr_size</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">arr_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="iterating-over-power-set-using-banker-s-sequence">
<h2>Iterating over power set, using banker&#8217;s&nbsp;sequence</h2>
<p>Using <a class="reference external" href="http://applied-math.org/subset.pdf">banker&#8217;s sequence</a> we can generate
subsets in a monotonically increasing order of cardinality. Depending on your
use case, it may be extremely useful. The idea is to use a bitmask as before
but we will consider all bitmasks with set bits = k before we consider any
mask with set bits &gt;&nbsp;k.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">powerset4</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr_size</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fill</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">mask</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">fill</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">mask</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>As Donald Knuth once remarked, there seems to be as many algorithms for
unsorting data as there are for sorting it. There are many approaches and
algorithms for power set generation. I hope I have provided a decent coverage
of the most popular&nbsp;ones.</p>
<p>As always, comments are&nbsp;welcome.</p>
</div>

  </div>
  <div class="article_meta">
    <p>Posted on: Mon 05 January 2015</p>
    <p>Category: <a href="http://www.j4nu5.com/category/programming.html">Programming</a>
 &ndash; Tags:
      <a href="http://www.j4nu5.com/tag/programming.html">programming</a>    </p>
  </div>

  <div id="article_comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_identifier = "generating-power-set.html";
        (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'http://j4nu5.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
    </script>
  </div>

</article>


    <div id="ending_message">
      <p>&copy; Kushagra Sinha. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>